Initial setup:

- using JDK 8.422 of Temurin distribution as a lower bound
- using Scala 2.13.15

Steps and observations:
- It is likely that the provided Java file is obtained with the help of FernFlower decompiler
- Also, it contains both files of a Scala class and a Scala object respectively
- Target marked with the java.io.Serializable (having no members, nothing to do)
- Target contains abstract methods `canEqual`, `productArity` and `productElement`, alongside with concrete methods `productPrefix` and `productIterator` of the `Product`
- `productElement` implementation is not 100% identical, and differs by decompiler; also, it seems the code was produced by an earlier version of a Scala compiler than I use here (assumed by the lack of the `scala.runtime.Statics.ioobe()` call in the provided class, while being generated by 2.13.15
- Presence of the `apply`, `unapply`, `copy`, `copy$default$1` and `copy$default$2` in the class indicates that the target is a case class
- Lack of `productElementName` means it is defined in a super class, eg `Expression`
- `Partitioning` being mentioned in an interface list, but not included into import list (and its name semantics), should be a parent trait for the `HashPartitioning`, existing in the same package
- The shape of the `private HashPartitioning$` in the object differs significantly when generated by the Scala 2.13 compiler, particularly using `scala.runtime.ModuleSerializationProxy`. Switching to the Scala 2.12 brings likeliness to
what is provided.
- using Scala 2.12.20 from this point
- `Unevaluable` trait provides methods `foldable`, `eval`, `doGenCode`
- `eval$default$1` method is generated for the `eval` one with a default value of its argument
- `Partitioning` trait provides methods `satisfies`, `flatten`
- `dataType` method isn't translated as expected, I may assume data types hierarchy is more complicated than it could be deduced from the provided Java file
- `Distribution` symbol is used without explicit import, should be provided from the same package
- `children` and `nullable` are methods of the target case class
- `DataType` and `IntegerType` seem to be related to each over, corresponding to the abstract base class and some (likely) concrete implementation
- `Partitioning` trait provides methods `satisfies0` which is overridden
- `public static final boolean $anonfun$...` declaration is typical for a Scala 2.12 compiler to generate for lambdas. There are 3 such instances for the `satisfies0` function. Being marked as synthetic methods, they should be declared in-place, rather than as explicit def or val to hold such a lambda. To reconstruct them, one may start with an explicitly defined functions, move them into the `satisfies0` non-synthetic one, place accordingly to the control flow and substitute calls to make compiler generate them for you.
- more or less the same technique is applied for the `project` method
- `createShuffleSpec` and `partitionIdExpression` have straightforward (at this point) implementations
- `withNewChildrenInternal:HashPartitioning` is accompanied by the synthetic/bridge method, meaning it has a counterpart in some of the superclasses. Within the scope of this task and its limitations, it's hard to deduce where exactly in
the class hierarchy it is declared
- see [this document](satisfaies0.md) for the detailed process of `satisfies0` reconstruction
